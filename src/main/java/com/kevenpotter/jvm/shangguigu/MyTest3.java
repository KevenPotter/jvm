package com.kevenpotter.jvm.shangguigu;

/**
 * 3.标记清除/标记整理算法major GC OR full GC:
 * 标记清除(Mark-Sweep):
 * 标记(Mark):从根集合开始扫描,对存活的对象进行标记;
 * 清除(Sweep):扫描整个内存空间,回收未被标记的对象,使用free-list记录可疑区域.
 * 优点:不需要额外空间
 * 缺点:两次扫描,耗时严重;会产生内存碎片
 * 1.效率比较低(递归与全堆对象遍历),而且进行GC的时候,需要停止应用程序,这会导致用户体验非常差劲;
 * 2.这种方式清理出来的空闲内存是不连续的,这点不难理解,我们的死亡对象都是随机的出现在内存的各个角落,现在把他们清除之后,内存
 * 的布局自然会乱七八糟.而为了应付这一点,JVM就不得不维持一个内存的空闲列表,这又是一种开销.而且在分配数组对象的时候,寻找连续
 * 的内存空间会不太好找.
 * 标记整理(Mark-Compact):
 * 缺点:该算法的唯一缺点就是效率也不高,不仅要标记所有存活对象,还要整理所有存活对象,还要整理所有存活对象的引用地址.从效率上来
 * 说,标记整理算法要低于复制算法
 * 老年代一般是由标记清除或者是标记清除与标记整理的混合实现
 * <p>
 * 内存效率:复制算法>标记清除算法>标记整理算法(此处的效率只是简单的对比时间复杂度,实际情况不一定如此)
 * 内存整齐度:复制算法=标记整理算法>标记清除算法
 * 内存利用率:标记整理算法=标记清除算法>复制算法
 * <p>
 * 注意,还有一种算法:分代收集算法
 */
public class MyTest3 {
}
